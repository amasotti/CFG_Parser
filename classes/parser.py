"""

Thi file contains the implementation of the following classes:
- Node
- Parser


"""
import os
import os.path
import svgling
import nltk

try:
    from .grammar import CFGGrammar
except (SystemError, ImportError):
    from classes.grammar import CFGGrammar


class Node(object):
    """
    Used for storing information about a non-terminal symbol. A node can have a maximum of two
    children because of the CNF of the grammar.
    It is possible though that there are multiple parses of a sentence. In this case information
    about an alternative child is stored in self.child1 or self.child2 (the parser will decide
    where according to the ambiguous rule).
    Either child1 is a terminal symbol passed as string, or both children are Nodes.
    """

    def __init__(self, symbol, child1, child2=None):
        self.symbol = symbol
        self.child1 = child1
        self.child2 = child2

    def __repr__(self):
        return self.symbol


def generate_tree(node):
    """
    Generates the string representation of the parse tree.
    :param node: the root node.
    :return: the parse tree in string form.
    """
    if node.child2 is None:
        return f"""("{node.symbol}", "{node.child1}")"""
    else:
        return f"""("{node.symbol}", {generate_tree(node.child1)}, {generate_tree(node.child2)})"""


class Parser(object):

    def __init__(self, grammar, sentence, parse_table=None):

        self.prods = {}

        self.start_symbol = "S"  # define start symbol

        # Load the PSG rules either from file or from json
        self.grammar = None
        self.load_grammar(grammar)
        self.parse_table = parse_table

        self.__call__(sentence)

    def __call__(self, sentence, parse=False):
        """
        Parse the given sentence (string or file) with the earlier given grammar.
        :param sentence: the sentence to parse with self.grammar
        """

        if os.path.isfile(sentence):
            with open(sentence, 'r') as inp:
                self.input = inp.read().split()
        else:
            self.input = sentence.split()
        if parse:
            self.parse()

    def load_grammar(self, grammar, save=True, output="./data/normalized.json"):
        """
        Reads in a CFG from a given file, converts it to CNF and stores it in self.grammar.

        :param
            grammar: the file in which the grammar is stored.
            save (bool): if True (default) saves the normalized grammar to a json file
            output : the path for the json file

        """
        print('Loading grammar...')
        try:
            # it could be a json already in normal form or a raw txt file:
            if grammar.endswith('.json'):
                print('From json')
                self.grammar = CFGGrammar(json_backup=grammar)
            else:
                print('From raw txt file')
                gram = CFGGrammar(raw_rules=grammar)
                self.grammar = gram.chomskyan_normal_form()
                if save:
                    gram.to_json(output_path=output)
        except (SystemError, IOError, ImportError):
            print('File path not found')

    def parse(self):
        """
        Does the actual parsing according to the Cocke-Younger-Kasami algorithm. The parse table is stored in
        self.parse_table.
        """
        length = len(self.input)
        # self.parse_table[y][x] is the list of nodes in the x+1 cell of y+1 row in the table.
        # That cell covers the word below it and y more words after.
        self.parse_table = [[[] for _ in range(length - y)] for y in range(length)]

        # First tier of the CYK Algorithm, look at each word as terminal nodes
        for i, word in enumerate(self.input):
            # Find out which non terminals can generate the terminals in the input string
            # and put them into the parse table. One terminal could be generated by multiple
            # non terminals, therefore the parse table will contain a list of non terminals.
            for rule in self.grammar:
                if f"'{word}'" == rule[1]:
                    self.parse_table[0][i].append(Node(rule[0], word))

        # Recursive part of the CYK Algorithm
        for words_to_consider in range(2, length + 1):
            for starting_cell in range(0, length - words_to_consider + 1):
                for left_size in range(1, words_to_consider):
                    right_size = words_to_consider - left_size

                    left_cell = self.parse_table[left_size - 1][starting_cell]
                    right_cell = self.parse_table[right_size - 1][starting_cell + left_size]

                    for rule in self.grammar:
                        left_nodes = [n for n in left_cell if n.symbol == rule[1]]
                        if left_nodes:
                            right_nodes = [n for n in right_cell if n.symbol == rule[2]]
                            self.parse_table[words_to_consider - 1][starting_cell].extend(
                                [Node(rule[0], left, right) for left in left_nodes for right in right_nodes]
                            )

    def to_tree(self, output=True, only_s=False, draw=True):
        """
        Print the parse tree starting with the start symbol. Alternatively it returns the string
        representation of the tree(s) instead of printing it.
        """
        # set start symbol
        start_symbol = self.start_symbol

        # extract all the possible derivation in the highest tier of the CYK-table
        if only_s:
            final_parsing = [n for n in self.parse_table[-1][0] if n.symbol == start_symbol]
        else:
            final_parsing = [n for n in self.parse_table[-1][0]]
        trees = []
        for derivation in final_parsing:
            trees.append(generate_tree(derivation))
        if trees:
            # clean duplicats
            trees = list(dict.fromkeys(trees))
            # trasnform in dictionary
            new_trees = {str(i): tree for i, tree in enumerate(trees)}
            if output:
                print("The sentence is well-formed")
                print("\nPossible parse(s):")
                for k, v in new_trees.items():
                    print(f"{k} \t str{v}")
                if draw:
                    while True:
                        print('Choose the index of a tree to draw it or -1 to quit')
                        try:
                            index = input('Index: ')
                            if index == "-1":
                                break
                            else:
                                self.draw_tree_nltk(new_trees[index])
                        except TypeError:
                            print('Wrong index, aborting...')
            return new_trees
        else:
            print('The sentence is not well-formed')

    @staticmethod
    def draw_tree_nltk(tree):
        tree = nltk.Tree.fromstring(tree)
        tree.draw()

    @staticmethod
    def draw_tree_svgling(tree):
        """
       The same as before, but uses svgling
       :param tree:
       :return:
       """
        tree = svgling.draw_tree(tree, leaf_nodes_align=True)
        print(f"Printing following tree:\n{tree}")
        picture = tree.get_svg()
        picture.saveas("./data/tree_test.svg")
        with open("./data/tree_test.svg", 'w', encoding='utf-8') as pic:
            picture.write(pic, pretty=True, indent=2)

    def __repr__(self):
        return 'Parser for CFG Grammars'
